/*
 * @file displayThread_entry.c
 * @brief
 *
 * Copyright DSE - Confidential - All rights reserved
 */

#include "displayThread.h"
#include "bsp_api.h"
#include "gx_api.h"
#include "gui/guiapp_specifications.h"
#include "gui/guiapp_resources.h"

#if defined(BSP_BOARD_S7G2_SK)
#include "hardware/lcd.h"
#endif

void displayThread_entry(void);

#if defined(BSP_BOARD_S7G2_SK)
void g_lcd_spi_callback(spi_callback_args_t * p_args);
#endif

uint32_t adcProm = 0;
ULONG setPointRx[1] = {0};
ULONG speedRx[1] = {0};
ULONG dutyCycleRx[1] = {0};

GX_WINDOW_ROOT * p_window_root;
extern GX_CONST GX_STUDIO_WIDGET *guiapp_widget_table[];

static GX_CHAR setPointBuffer[5];
static GX_CHAR speedBuffer[6];
static GX_CHAR dutyCycleBuffer[4];

/*******************************************************************************************************************//**
    @brief  Primary logic for handling events generated by the various sub-systems.
 ***********************************************************************************************************************/
void displayThread_entry(void) {
    GX_PROMPT * setPointPrompt;
    GX_PROMPT * speedPrompt;
    GX_PROMPT * dutyCyclePrompt;

    ssp_err_t        err;
    UINT      status = TX_SUCCESS;

    /* Initializes GUIX. */
    status = gx_system_initialize();
    if(TX_SUCCESS != status)
    {
        while(1);
    }

    /* Initializes GUIX drivers. */
    err = g_sf_el_gx.p_api->open (g_sf_el_gx.p_ctrl, g_sf_el_gx.p_cfg);
    if(SSP_SUCCESS != err)
    {
        while(1);
    }

    gx_studio_display_configure ( DISPLAY_1,
                                  g_sf_el_gx.p_api->setup,
                                  LANGUAGE_ENGLISH,
                                  DISPLAY_1_THEME_1,
                                  &p_window_root );

    err = g_sf_el_gx.p_api->canvasInit(g_sf_el_gx.p_ctrl, p_window_root);
    if(SSP_SUCCESS != err)
    {
        while(1);
    }

    // Create the widgets we have defined with the GUIX data structures and resources.
    GX_CONST GX_STUDIO_WIDGET ** pp_studio_widget = &guiapp_widget_table[0];
    GX_WIDGET * p_first_screen = NULL;

    while (GX_NULL != *pp_studio_widget)
    {
        // We must first create the widgets according the data generated in GUIX Studio.

        // Once we are working on the widget we want to see first, save the pointer for later.
        if (0 == strcmp("window1", (char*)(*pp_studio_widget)->widget_name))
        {
            gx_studio_named_widget_create((*pp_studio_widget)->widget_name, (GX_WIDGET *)p_window_root, GX_NULL);
        } else {
            gx_studio_named_widget_create((*pp_studio_widget)->widget_name, GX_NULL, GX_NULL);
        }
        // Move to next top-level widget
        pp_studio_widget++;
    }
    // Attach the first screen to the root so we can see it when the root is shown
   gx_widget_attach(p_window_root, p_first_screen);


    if(TX_SUCCESS != status)
    {
            while(1);
    }

    /* Shows the root window to make it and patients screen visible. */
    status = gx_widget_show(p_window_root);
    if(TX_SUCCESS != status)
    {
        while(1);
    }

    /* Lets GUIX run. */
    status = gx_system_start();
    if(TX_SUCCESS != status)
    {
        while(1);
    }

#if defined(BSP_BOARD_S7G2_SK)
    /** Open the SPI driver to initialize the LCD (SK-S7G2) **/
    err = g_spi_lcdc.p_api->open(g_spi_lcdc.p_ctrl, (spi_cfg_t *)g_spi_lcdc.p_cfg);
    if (err)
    {
        while(1);
    }
    /** Setup the ILI9341V (SK-S7G2) **/
    ILI9341V_Init();
#endif

    /* Controls the GPIO pin for LCD ON (DK-S7G2, PE-HMI1) */
#if defined(BSP_BOARD_S7G2_DK)
    err = g_ioport.p_api->pinWrite(IOPORT_PORT_07_PIN_10, IOPORT_LEVEL_HIGH);
    if (err)
    {
        while(1);
    }
#elif defined(BSP_BOARD_S7G2_PE_HMI1)
    err = g_ioport.p_api->pinWrite(IOPORT_PORT_10_PIN_03, IOPORT_LEVEL_HIGH);
    if (err)
    {
        while(1);
    }
#endif

    /* Opens PWM driver and controls the TFT panel back light (DK-S7G2, PE-HMI1) */
#if defined(BSP_BOARD_S7G2_DK) || defined(BSP_BOARD_S7G2_PE_HMI1)
    err = g_pwm_backlight.p_api->open(g_pwm_backlight.p_ctrl, g_pwm_backlight.p_cfg);
    if (err)
    {
        while(1);
    }
#endif

    /* Set the prompt pointer to txt_counter widget */
    status = gx_system_widget_find(ID_SET_POINT, GX_SEARCH_DEPTH_INFINITE, (GX_WIDGET **) &setPointPrompt);
    if (status)
        while (1);
    status = gx_system_widget_find(ID_SPEED, GX_SEARCH_DEPTH_INFINITE, (GX_WIDGET **) &speedPrompt);
    if (status)
        while (1);
    status = gx_system_widget_find(ID_DUTY_CYCLE, GX_SEARCH_DEPTH_INFINITE, (GX_WIDGET **) &dutyCyclePrompt);
    if (status)
        while (1);

    /* Attach txt_buffer to txt_counter widget */
    status = gx_prompt_text_set(setPointPrompt, setPointBuffer);
    if (status)
        while (1);
    status = gx_prompt_text_set(speedPrompt, speedBuffer);
        if (status)
            while (1);
    status = gx_prompt_text_set(dutyCyclePrompt, dutyCycleBuffer);
        if (status)
            while (1);

    while(1)
    {
        tx_queue_receive(&gSetPointDisplayQueue, setPointRx, 20);
        tx_queue_receive(&gSpeedDisplayQueue, speedRx, 20);
        tx_queue_receive(&gDutyCycleDisplayQueue, dutyCycleRx, 20);

        /* Convert current counter value to string */
        gx_utility_ltoa((LONG) setPointRx[0], setPointBuffer, 5);
        gx_utility_ltoa((LONG) speedRx[0], speedBuffer, 6);
        gx_utility_ltoa((LONG) dutyCycleRx[0], dutyCycleBuffer, 4);

        /* Let GUIX know that txt_counter should be re-drawn */
        status = gx_system_dirty_mark((GX_WIDGET *) setPointPrompt);
        if (status)
            while (1);
        status = gx_system_dirty_mark((GX_WIDGET *) speedPrompt);
        if (status)
            while (1);
        status = gx_system_dirty_mark((GX_WIDGET *) dutyCyclePrompt);
        if (status)
            while (1);

        /* Force re-draw all "dirty" widgets */
        gx_system_canvas_refresh();

        tx_thread_sleep(1);
    }
}

#if defined(BSP_BOARD_S7G2_SK)
void g_lcd_spi_callback(spi_callback_args_t * p_args)
{
    (void)p_args;
    tx_semaphore_ceiling_put(&g_main_semaphore_lcdc, 1);
}
#endif
